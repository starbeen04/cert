#!/usr/bin/env python3
"""
ğŸš€ ì‹¤ì „ íŒŒì´í”„ë¼ì¸: PDF êµ¬ì¡°íŒŒì•… â†’ ì •ê·œìŠ¤í‚¤ë§ˆ ì €ì¥ â†’ LLM ìœ í˜•/ì±•í„° íƒœê¹…
ì‚¬ìš©ì ì œì‹œ ìš”êµ¬ì‚¬í•­ì„ ì™„ì „ ë°˜ì˜í•œ ì „ë¬¸ì  ì²˜ë¦¬ ì‹œìŠ¤í…œ
"""

import re
import json
import base64
import os
import asyncio
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
import fitz  # PyMuPDF
import openai
from datetime import datetime
import csv
import uuid

class ProfessionalPDFPipeline:
    """ì‹¤ì „ PDF ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸"""
    
    def __init__(self, openai_client: openai.AsyncOpenAI):
        self.openai_client = openai_client
        
        # ì‹¤ì œ PDFì—ì„œ ê°ì§€ëœ ê·œì¹™ ì ìš©
        self.PDF_RULES = {
            "total_questions": 60,
            "choices_per_question": 4,
            "choice_markers": ["â‘ ", "â‘¡", "â‘¢", "â‘£"],
            "subjects": {
                "1-20": "ì •ë³´ì‹œìŠ¤í…œ ê¸°ë°˜ ê¸°ìˆ ", 
                "21-40": "í”„ë¡œê·¸ë˜ë° ì–¸ì–´ í™œìš©",
                "41-60": "ë°ì´í„°ë² ì´ìŠ¤ í™œìš©"
            },
            "special_questions": {
                "table": [6],      # ìŠ¤ì¼€ì¤„ë§ í‘œ
                "image_choices": [15],  # ERD ê¸°í˜¸ (ì„ íƒì§€ê°€ ì´ë¯¸ì§€)
                "code": [24, 33, 40],   # Java ì½”ë“œ ë¸”ë¡
                "diagram": [56]    # íŠ¸ë¦¬ ê·¸ë¦¼
            },
            "pages": {
                "questions": [1, 2, 3, 4],  # ë¬¸ì œ í˜ì´ì§€
                "answers": [5, 6, 7, 8]     # ì •ë‹µ/í•´ì„¤ í˜ì´ì§€
            }
        }
    
    async def process_pdf_professional(self, pdf_path: str, upload_id: int) -> Dict[str, Any]:
        """ì‹¤ì „ íŒŒì´í”„ë¼ì¸ ë©”ì¸ ì²˜ë¦¬"""
        
        print(f"ğŸš€ ì‹¤ì „ íŒŒì´í”„ë¼ì¸ ì‹œì‘ - Upload {upload_id}")
        print("=" * 80)
        
        try:
            # === Aë‹¨ê³„: êµ¬ì¡° íŒŒì•… ===
            print("ğŸ“‹ Aë‹¨ê³„: PDF êµ¬ì¡° íŒŒì•… ì‹œì‘")
            structure_data = await self._stage_a_structure_analysis(pdf_path, upload_id)
            
            if not structure_data["success"]:
                return {"success": False, "error": "Aë‹¨ê³„ êµ¬ì¡° íŒŒì•… ì‹¤íŒ¨"}
            
            # === Bë‹¨ê³„: ì •ê·œ ìŠ¤í‚¤ë§ˆ ì €ì¥ ===
            print("ğŸ“Š Bë‹¨ê³„: ì •ê·œ ìŠ¤í‚¤ë§ˆ ì €ì¥ ì‹œì‘")
            schema_result = await self._stage_b_schema_storage(structure_data, upload_id)
            
            if not schema_result["success"]:
                return {"success": False, "error": "Bë‹¨ê³„ ìŠ¤í‚¤ë§ˆ ì €ì¥ ì‹¤íŒ¨"}
            
            # === Cë‹¨ê³„: LLM ìœ í˜•/ì±•í„° íƒœê¹… ===
            print("ğŸ·ï¸ Cë‹¨ê³„: LLM ìœ í˜•/ì±•í„° íƒœê¹… ì‹œì‘")
            tagging_result = await self._stage_c_llm_tagging(schema_result, upload_id)
            
            print("âœ… ì‹¤ì „ íŒŒì´í”„ë¼ì¸ ì™„ë£Œ!")
            return {
                "success": True,
                "structure_data": structure_data,
                "schema_result": schema_result,
                "tagging_result": tagging_result,
                "total_questions": len(schema_result.get("questions", [])),
                "processing_method": "professional_pipeline"
            }
            
        except Exception as e:
            print(f"âŒ ì‹¤ì „ íŒŒì´í”„ë¼ì¸ ì‹¤íŒ¨: {e}")
            return {"success": False, "error": str(e)}
    
    async def _stage_a_structure_analysis(self, pdf_path: str, upload_id: int) -> Dict[str, Any]:
        """Aë‹¨ê³„: êµ¬ì¡° íŒŒì•… ë‹¨ê³„"""
        
        print("ğŸ” A-1: í˜ì´ì§€/ì´ë¯¸ì§€ ì¤€ë¹„")
        assets_dir = Path(f"assets/upload_{upload_id}")
        assets_dir.mkdir(parents=True, exist_ok=True)
        
        # A-1: PDF â†’ í˜ì´ì§€ ì´ë¯¸ì§€ (300dpi)
        pages_data = await self._prepare_pages_and_images(pdf_path, assets_dir)
        
        print("ğŸ” A-2: ë¬¸í•­/ì´ë¡  êµ¬ë¶„")
        # A-2: Q/A í˜ì´ì§€ vs í•´ì„¤ í˜ì´ì§€ êµ¬ë¶„
        page_classification = self._classify_pages(pages_data)
        
        print("ğŸ” A-3: ë¬¸í•­ ë¸”ë¡ ì„¸ê·¸ë¨¼íŠ¸")
        # A-3: ë¬¸í•­ ë¸”ë¡ ì„¸ê·¸ë¨¼íŠ¸
        question_blocks = await self._segment_question_blocks(pages_data, page_classification)
        
        print("ğŸ” A-4: ê³¼ëª©/ìê²©ì¦ ì‹ë³„")
        # A-4: ê³¼ëª©/ìê²©ì¦Â·ì‹œí—˜ëª… ì‹ë³„
        exam_info = self._identify_exam_info(pages_data)
        
        print("ğŸ” A-5: ë³´ê¸° ë° íŠ¹ìˆ˜ ìš”ì†Œ ê°ì§€")
        # A-5: 'ë³´ê¸°'(passage) ë° íŠ¹ìˆ˜ ìš”ì†Œ ê°ì§€
        special_elements = await self._detect_special_elements(question_blocks, assets_dir)
        
        print("ğŸ” A-6: ì„ íƒì§€ ìˆ˜/í¬ë¡œìŠ¤ í˜ì´ì§€ íŒì •")
        # A-6: ì„ íƒì§€ ìˆ˜/í˜ì´ì§€ ë„˜ì–´ê° íŒì •
        choice_analysis = self._analyze_choices_and_cross_page(question_blocks)
        
        print("ğŸ” A-7: ì •ë‹µí‘œ/í•´ì„¤ íŒŒì‹±")
        # A-7: ì •ë‹µí‘œ/í•´ì„¤ íŒŒì‹± & ê²€ì¦
        answers_explanations = self._parse_answers_and_explanations(pages_data, page_classification)
        
        return {
            "success": True,
            "upload_id": upload_id,
            "assets_dir": str(assets_dir),
            "pages_data": pages_data,
            "page_classification": page_classification,
            "question_blocks": question_blocks,
            "exam_info": exam_info,
            "special_elements": special_elements,
            "choice_analysis": choice_analysis,
            "answers_explanations": answers_explanations
        }
    
    async def _prepare_pages_and_images(self, pdf_path: str, assets_dir: Path) -> Dict[str, Any]:
        """A-1: í˜ì´ì§€ ì´ë¯¸ì§€ ë° í…ìŠ¤íŠ¸+ì¢Œí‘œ ì¶”ì¶œ"""
        
        doc = fitz.open(pdf_path)
        pages_data = {
            "total_pages": len(doc),
            "pages": []
        }
        
        # í˜ì´ì§€ë³„ ì²˜ë¦¬
        for page_num in range(len(doc)):
            page = doc[page_num]
            page_info = {
                "page_number": page_num + 1,
                "image_path": None,
                "layout_data": None,
                "raw_text": page.get_text(),
                "text_blocks": []
            }
            
            # 300dpi PNG ìƒì„±
            mat = fitz.Matrix(4.17, 4.17)  # 300dpi â‰ˆ 4.17ë°°
            pix = page.get_pixmap(matrix=mat)
            
            page_image_path = assets_dir / "pages" / f"page_{page_num+1:02d}.png"
            page_image_path.parent.mkdir(exist_ok=True)
            pix.save(str(page_image_path))
            page_info["image_path"] = str(page_image_path)
            
            # í…ìŠ¤íŠ¸+ì¢Œí‘œ ì¶”ì¶œ
            text_dict = page.get_text("dict")
            layout_data = []
            
            for block in text_dict["blocks"]:
                if "lines" in block:
                    for line in block["lines"]:
                        for span in line["spans"]:
                            layout_data.append({
                                "text": span["text"],
                                "bbox": span["bbox"],  # [x0, y0, x1, y1]
                                "font": span["font"],
                                "size": span["size"],
                                "flags": span["flags"]
                            })
            
            # ë ˆì´ì•„ì›ƒ JSON ì €ì¥
            layout_path = assets_dir / "layout" / f"page_{page_num+1}.json"
            layout_path.parent.mkdir(exist_ok=True)
            with open(layout_path, 'w', encoding='utf-8') as f:
                json.dump(layout_data, f, ensure_ascii=False, indent=2)
            
            page_info["layout_data"] = str(layout_path)
            page_info["text_blocks"] = [item["text"] for item in layout_data]
            
            pages_data["pages"].append(page_info)
            print(f"   ğŸ“„ í˜ì´ì§€ {page_num+1} ì²˜ë¦¬ ì™„ë£Œ: {len(layout_data)}ê°œ í…ìŠ¤íŠ¸ ë¸”ë¡")
        
        doc.close()
        return pages_data
    
    def _classify_pages(self, pages_data: Dict[str, Any]) -> Dict[str, Any]:
        """A-2: ë¬¸í•­/ì´ë¡  êµ¬ë¶„ (Q/A í˜ì´ì§€ vs í•´ì„¤ í˜ì´ì§€)"""
        
        classification = {
            "question_pages": [],
            "answer_pages": [],
            "explanation_pages": []
        }
        
        # ì‹¤ì œ PDF ê·œì¹™ ì ìš©
        for page_info in pages_data["pages"]:
            page_num = page_info["page_number"]
            text = page_info["raw_text"]
            
            # ê·œì¹™ ê¸°ë°˜ ë¶„ë¥˜
            if page_num in self.PDF_RULES["pages"]["questions"]:
                classification["question_pages"].append(page_num)
            elif page_num in self.PDF_RULES["pages"]["answers"]:
                # "ì •ë‹µ ë° í•´ì„¤" í‚¤ì›Œë“œë¡œ ì¬ê²€ì¦
                if "ì •ë‹µ" in text and "í•´ì„¤" in text:
                    classification["answer_pages"].append(page_num)
                else:
                    classification["explanation_pages"].append(page_num)
        
        print(f"   ğŸ“‹ í˜ì´ì§€ ë¶„ë¥˜: ë¬¸ì œ {classification['question_pages']}, ì •ë‹µ/í•´ì„¤ {classification['answer_pages'] + classification['explanation_pages']}")
        return classification
    
    async def _segment_question_blocks(self, pages_data: Dict[str, Any], classification: Dict[str, Any]) -> List[Dict[str, Any]]:
        """A-3: ë¬¸í•­ ë¸”ë¡ ì„¸ê·¸ë¨¼íŠ¸ - 2ë‹¨ê³„ ì •ë°€ ë¶„ì„"""
        
        # 1ë‹¨ê³„: ê° í˜ì´ì§€ë³„ ì´ˆê¸° ë¶„ì„
        all_questions = []
        page_questions_map = {}
        
        for page_info in pages_data["pages"]:
            if page_info["page_number"] not in classification["question_pages"]:
                continue
                
            print(f"   ğŸ” í˜ì´ì§€ {page_info['page_number']} 1ì°¨ Vision ë¶„ì„ ì¤‘...")
            page_questions = await self._analyze_page_with_vision(page_info)
            all_questions.extend(page_questions)
            page_questions_map[page_info['page_number']] = page_questions
        
        print(f"   ğŸ“Š 1ì°¨ ë¶„ì„ ì™„ë£Œ: {len(all_questions)}ê°œ ë¬¸ì œ ì¶”ì¶œ")
        
        # 2ë‹¨ê³„: ëˆ„ë½/ì˜¤ë¥˜ ê²€ì¦ ë° ì¬ë¶„ì„
        verified_questions = await self._verify_and_fix_questions(all_questions, pages_data, classification)
        
        print(f"   ğŸ“ ìµœì¢… ë¬¸í•­ ë¸”ë¡: {len(verified_questions)}ê°œ ë¬¸ì œ")
        return verified_questions
    
    async def _verify_and_fix_questions(self, questions: List[Dict], pages_data: Dict, classification: Dict) -> List[Dict]:
        """2ë‹¨ê³„: ëˆ„ë½/ì˜¤ë¥˜ ë¬¸ì œ ê²€ì¦ ë° ìˆ˜ì •"""
        
        print(f"   ğŸ” 2ë‹¨ê³„: ë¬¸ì œ ê²€ì¦ ë° ë³´ì™„ ì‹œì‘")
        
        # 1. ë¬¸ì œ ë²ˆí˜¸ ë¶„ì„
        found_numbers = {q['question_number'] for q in questions}
        expected_numbers = set(range(1, 61))  # 1-60ë²ˆ ë¬¸ì œ
        missing_numbers = expected_numbers - found_numbers
        
        if missing_numbers:
            print(f"      ğŸš¨ ëˆ„ë½ëœ ë¬¸ì œ: {sorted(missing_numbers)}")
            
            # ëˆ„ë½ëœ ë¬¸ì œë“¤ ì¬ë¶„ì„
            for missing_num in sorted(missing_numbers):
                recovered_question = await self._recover_missing_question(missing_num, pages_data, classification)
                if recovered_question:
                    questions.append(recovered_question)
                    print(f"      âœ… ë¬¸ì œ {missing_num}ë²ˆ ë³µêµ¬ ì™„ë£Œ")
        
        # 2. í¬ë¡œìŠ¤ í˜ì´ì§€ ë¬¸ì œ ì²˜ë¦¬
        questions = await self._fix_cross_page_questions(questions, pages_data)
        
        # 3. íŠ¹ìˆ˜ ìš”ì†Œ ì¬ê²€ì¦ (í‘œ, ë‹¤ì´ì–´ê·¸ë¨, ì½”ë“œ)
        questions = await self._enhance_special_elements(questions, pages_data)
        
        return questions
    
    async def _recover_missing_question(self, question_num: int, pages_data: Dict, classification: Dict) -> Optional[Dict]:
        """ëˆ„ë½ëœ ë¬¸ì œ ë³µêµ¬"""
        
        # ë¬¸ì œ ë²ˆí˜¸ ë²”ìœ„ë¡œ í˜ì´ì§€ ì¶”ì •
        if 1 <= question_num <= 15:
            target_page = 1
        elif 16 <= question_num <= 30:
            target_page = 2
        elif 31 <= question_num <= 45:
            target_page = 3
        else:
            target_page = 4
            
        page_info = None
        for page in pages_data["pages"]:
            if page["page_number"] == target_page:
                page_info = page
                break
        
        if not page_info:
            return None
            
        print(f"      ğŸ” ë¬¸ì œ {question_num}ë²ˆ í˜ì´ì§€ {target_page}ì—ì„œ ì¬íƒìƒ‰ ì¤‘...")
        
        # íŠ¹ì • ë¬¸ì œ ë²ˆí˜¸ì— ì§‘ì¤‘í•œ í”„ë¡¬í”„íŠ¸
        focused_result = await self._analyze_specific_question(page_info, question_num)
        return focused_result
    
    async def _analyze_specific_question(self, page_info: Dict, target_question_num: int) -> Optional[Dict]:
        """íŠ¹ì • ë¬¸ì œ ë²ˆí˜¸ì— ì§‘ì¤‘í•œ ë¶„ì„"""
        
        image_path = page_info["image_path"]
        with open(image_path, "rb") as image_file:
            image_data = base64.b64encode(image_file.read()).decode('utf-8')
        
        prompt = f"""ì´ í˜ì´ì§€ì—ì„œ ë¬¸ì œ {target_question_num}ë²ˆë§Œ ì •í™•íˆ ì°¾ì•„ì„œ ì¶”ì¶œí•´ ì£¼ì„¸ìš”.

í˜ì´ì§€ì—ì„œ "{target_question_num}."ë¡œ ì‹œì‘í•˜ëŠ” ë¬¸ì œë¥¼ ì°¾ì•„ì„œ ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œ ë°˜í™˜í•˜ì„¸ìš”:

```json
{{
  "question_number": {target_question_num},
  "question_text": "ë¬¸ì œ {target_question_num}ë²ˆì˜ ì „ì²´ ë‚´ìš©",
  "choices": [
    {{"marker": "â‘ ", "content": "ì„ íƒì§€ 1"}},
    {{"marker": "â‘¡", "content": "ì„ íƒì§€ 2"}},
    {{"marker": "â‘¢", "content": "ì„ íƒì§€ 3"}},
    {{"marker": "â‘£", "content": "ì„ íƒì§€ 4"}}
  ],
  "passage": "ë³´ê¸°ë‚˜ ì§€ë¬¸ì´ ìˆìœ¼ë©´",
  "has_table": false,
  "has_image": false,
  "has_code": false
}}
```

ì£¼ì˜: 
- ë¬¸ì œ {target_question_num}ë²ˆë§Œ ì°¾ìœ¼ì„¸ìš”
- ì„ íƒì§€ê°€ ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ì–´ê°”ì„ ìˆ˜ ìˆìœ¼ë‹ˆ ì£¼ì˜ê¹Šê²Œ í™•ì¸í•˜ì„¸ìš”
- í‘œë‚˜ ë‹¤ì´ì–´ê·¸ë¨ì´ ìˆìœ¼ë©´ has_table, has_imageë¥¼ trueë¡œ ì„¤ì •í•˜ì„¸ìš”"""

        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "system", 
                        "content": f"ë¬¸ì œ {target_question_num}ë²ˆ ì „ë¬¸ ì¶”ì¶œê°€. í•´ë‹¹ ë¬¸ì œë§Œ ì •í™•íˆ ì°¾ì•„ì„œ ì™„ì „íˆ ì¶”ì¶œí•©ë‹ˆë‹¤."
                    },
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/png;base64,{image_data}",
                                    "detail": "high"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=4000,
                temperature=0.1
            )
            
            response_text = response.choices[0].message.content
            result = self._parse_questions_json(response_text)
            
            if result and 'question_number' in result:
                return result
            elif result and 'questions' in result and result['questions']:
                return result['questions'][0]
                
            return None
            
        except Exception as e:
            print(f"      âŒ ë¬¸ì œ {target_question_num}ë²ˆ ë³µêµ¬ ì‹¤íŒ¨: {e}")
            return None
    
    async def _fix_cross_page_questions(self, questions: List[Dict], pages_data: Dict) -> List[Dict]:
        """í¬ë¡œìŠ¤ í˜ì´ì§€ ë¬¸ì œ ì²˜ë¦¬ - ì„ íƒì§€ê°€ ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ì–´ê°„ ê²½ìš°"""
        
        print(f"      ğŸ”— í¬ë¡œìŠ¤ í˜ì´ì§€ ë¬¸ì œ ê²€ì‚¬ ì¤‘...")
        fixed_questions = []
        
        for question in questions:
            # ì„ íƒì§€ê°€ 2ê°œ ë¯¸ë§Œì¸ ê²½ìš° í¬ë¡œìŠ¤ í˜ì´ì§€ì¼ ê°€ëŠ¥ì„±
            if len(question.get('choices', [])) < 4:
                print(f"      ğŸ”— ë¬¸ì œ {question['question_number']}ë²ˆ ì„ íƒì§€ ë¶€ì¡± - ë‹¤ìŒ í˜ì´ì§€ í™•ì¸")
                
                # ë‹¤ìŒ í˜ì´ì§€ì—ì„œ ë‚˜ë¨¸ì§€ ì„ íƒì§€ ì°¾ê¸°
                enhanced_question = await self._find_remaining_choices(question, pages_data)
                fixed_questions.append(enhanced_question)
            else:
                fixed_questions.append(question)
        
        return fixed_questions
    
    async def _find_remaining_choices(self, question: Dict, pages_data: Dict) -> Dict:
        """ë‹¤ìŒ í˜ì´ì§€ì—ì„œ ë‚˜ë¨¸ì§€ ì„ íƒì§€ ì°¾ê¸°"""
        
        current_page = question.get('page_number', 1)
        next_page = current_page + 1
        
        # ë‹¤ìŒ í˜ì´ì§€ ì •ë³´ ì°¾ê¸°
        next_page_info = None
        for page in pages_data["pages"]:
            if page["page_number"] == next_page:
                next_page_info = page
                break
        
        if not next_page_info:
            return question
        
        # ë‹¤ìŒ í˜ì´ì§€ì—ì„œ ì´ì–´ì§„ ì„ íƒì§€ ì°¾ê¸°
        try:
            image_path = next_page_info["image_path"]
            with open(image_path, "rb") as image_file:
                image_data = base64.b64encode(image_file.read()).decode('utf-8')
            
            prompt = f"""ì´ í˜ì´ì§€ ìƒë‹¨ì— ë¬¸ì œ {question['question_number']}ë²ˆì˜ ì´ì–´ì§„ ì„ íƒì§€ê°€ ìˆëŠ”ì§€ í™•ì¸í•´ ì£¼ì„¸ìš”.

í˜„ì¬ê¹Œì§€ ì°¾ì€ ì„ íƒì§€:
{[choice.get('content', '') for choice in question.get('choices', [])]}

í˜ì´ì§€ ìƒë‹¨ì—ì„œ ì´ì–´ì§„ ì„ íƒì§€ (â‘¢, â‘£ ë“±)ë¥¼ ì°¾ì•„ì„œ JSONìœ¼ë¡œ ë°˜í™˜í•´ ì£¼ì„¸ìš”:

```json
{{
  "remaining_choices": [
    {{"marker": "â‘¢", "content": "ì„ íƒì§€ 3"}},
    {{"marker": "â‘£", "content": "ì„ íƒì§€ 4"}}
  ]
}}
```"""

            response = await self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/png;base64,{image_data}",
                                    "detail": "high"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=2000,
                temperature=0.1
            )
            
            response_text = response.choices[0].message.content
            result = self._parse_questions_json(response_text)
            
            if result and 'remaining_choices' in result:
                # ê¸°ì¡´ ì„ íƒì§€ì— ì¶”ê°€
                question['choices'].extend(result['remaining_choices'])
                print(f"      âœ… ë¬¸ì œ {question['question_number']}ë²ˆ ì„ íƒì§€ ë³´ì™„ ì™„ë£Œ")
            
        except Exception as e:
            print(f"      âš ï¸ ë¬¸ì œ {question['question_number']}ë²ˆ ì„ íƒì§€ ë³´ì™„ ì‹¤íŒ¨: {e}")
        
        return question
    
    async def _enhance_special_elements(self, questions: List[Dict], pages_data: Dict) -> List[Dict]:
        """íŠ¹ìˆ˜ ìš”ì†Œ (í‘œ, ë‹¤ì´ì–´ê·¸ë¨, ì½”ë“œ) ì²˜ë¦¬ ê°•í™”"""
        
        print(f"      ğŸ¨ íŠ¹ìˆ˜ ìš”ì†Œ ì¬ê²€ì¦ ì¤‘...")
        
        # íŠ¹ìˆ˜ ë¬¸ì œë¡œ ì˜ˆìƒë˜ëŠ” ë²ˆí˜¸ë“¤
        special_candidates = [6, 15, 24, 33, 40, 56]  # ê¸°ì¡´ ê·œì¹™ ê¸°ë°˜
        
        enhanced_questions = []
        for question in questions:
            if question['question_number'] in special_candidates:
                print(f"      ğŸ¨ ë¬¸ì œ {question['question_number']}ë²ˆ íŠ¹ìˆ˜ ìš”ì†Œ ì¬ë¶„ì„ ì¤‘...")
                enhanced_q = await self._reanalyze_special_question(question, pages_data)
                enhanced_questions.append(enhanced_q)
            else:
                enhanced_questions.append(question)
        
        return enhanced_questions
    
    async def _reanalyze_special_question(self, question: Dict, pages_data: Dict) -> Dict:
        """íŠ¹ìˆ˜ ë¬¸ì œ ì¬ë¶„ì„ - í‘œ, ë‹¤ì´ì–´ê·¸ë¨, ì½”ë“œ ì •í™•í•œ ì¸ì‹"""
        
        # í•´ë‹¹ í˜ì´ì§€ ì°¾ê¸°
        page_info = None
        for page in pages_data["pages"]:
            if page["page_number"] == question.get('page_number', 1):
                page_info = page
                break
        
        if not page_info:
            return question
        
        try:
            image_path = page_info["image_path"]
            with open(image_path, "rb") as image_file:
                image_data = base64.b64encode(image_file.read()).decode('utf-8')
            
            prompt = f"""ë¬¸ì œ {question['question_number']}ë²ˆì„ ë‹¤ì‹œ ì •ë°€ ë¶„ì„í•´ ì£¼ì„¸ìš”.

íŠ¹íˆ ë‹¤ìŒ ìš”ì†Œë“¤ì„ ì •í™•íˆ í™•ì¸í•´ ì£¼ì„¸ìš”:
- í‘œ(í…Œì´ë¸”)ê°€ ìˆëŠ”ê°€?
- ë‹¤ì´ì–´ê·¸ë¨ì´ë‚˜ ê·¸ë¦¼ì´ ìˆëŠ”ê°€? 
- ì½”ë“œ ë¸”ë¡ì´ ìˆëŠ”ê°€?
- ë³´ê¸°ë‚˜ ì§€ë¬¸ì˜ ë‚´ìš©ì´ ì™„ì „í•œê°€?

ì •í™•í•œ ë‚´ìš©ìœ¼ë¡œ ë‹¤ì‹œ ì¶”ì¶œí•´ ì£¼ì„¸ìš”:

```json
{{
  "question_number": {question['question_number']},
  "question_text": "ì •í™•í•œ ë¬¸ì œ ë‚´ìš©",
  "choices": [
    {{"marker": "â‘ ", "content": "ì •í™•í•œ ì„ íƒì§€ 1"}},
    {{"marker": "â‘¡", "content": "ì •í™•í•œ ì„ íƒì§€ 2"}},
    {{"marker": "â‘¢", "content": "ì •í™•í•œ ì„ íƒì§€ 3"}},
    {{"marker": "â‘£", "content": "ì •í™•í•œ ì„ íƒì§€ 4"}}
  ],
  "passage": "ì™„ì „í•œ ë³´ê¸°/ì§€ë¬¸ ë‚´ìš©",
  "has_table": false,
  "has_image": false,
  "has_code": false
}}
```

ì£¼ì˜ì‚¬í•­:
- í‘œì˜ ìˆ«ìë¥¼ ì •í™•íˆ ì½ìœ¼ì„¸ìš”
- ë‹¤ì´ì–´ê·¸ë¨ ì„¤ëª…ì„ ì™„ì „íˆ í¬í•¨í•˜ì„¸ìš”  
- ì½”ë“œëŠ” ë¬¸ë²•ì„ ì •í™•íˆ ì¸ì‹í•˜ì„¸ìš”
- ê¸€ìê°€ íë¦¿í•˜ë©´ ë¬¸ë§¥ìœ¼ë¡œ ì¶”ì •í•˜ì„¸ìš”"""

            response = await self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "system",
                        "content": "íŠ¹ìˆ˜ ìš”ì†Œ ì „ë¬¸ ë¶„ì„ê°€. í‘œ, ë‹¤ì´ì–´ê·¸ë¨, ì½”ë“œë¥¼ ì •ë°€í•˜ê²Œ ì¸ì‹í•©ë‹ˆë‹¤."
                    },
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/png;base64,{image_data}",
                                    "detail": "high"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=6000,
                temperature=0.1
            )
            
            response_text = response.choices[0].message.content
            result = self._parse_questions_json(response_text)
            
            if result and 'question_number' in result:
                print(f"      âœ… ë¬¸ì œ {question['question_number']}ë²ˆ íŠ¹ìˆ˜ ìš”ì†Œ ì¬ë¶„ì„ ì™„ë£Œ")
                return result
            elif result and 'questions' in result and result['questions']:
                return result['questions'][0]
                
        except Exception as e:
            print(f"      âŒ ë¬¸ì œ {question['question_number']}ë²ˆ íŠ¹ìˆ˜ ìš”ì†Œ ì¬ë¶„ì„ ì‹¤íŒ¨: {e}")
        
        return question
    
    async def _analyze_page_with_vision(self, page_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """OpenAI Vision APIë¡œ í˜ì´ì§€ ë¶„ì„í•˜ì—¬ ì‹¤ì œ ë¬¸ì œ ì¶”ì¶œ"""
        
        # ì´ë¯¸ì§€ë¥¼ base64ë¡œ ì¸ì½”ë”©
        image_path = page_info["image_path"]
        with open(image_path, "rb") as image_file:
            image_data = base64.b64encode(image_file.read()).decode('utf-8')
        
        prompt = f"""ì´ PDF í˜ì´ì§€ {page_info['page_number']}ì—ì„œ ëª¨ë“  ì‹œí—˜ ë¬¸ì œë¥¼ ì •í™•íˆ ì¶”ì¶œí•´ ì£¼ì„¸ìš”.

ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš” (ë‹¤ë¥¸ í…ìŠ¤íŠ¸ ì—†ì´):

```json
{{
  "questions": [
    {{
      "question_number": 1,
      "question_text": "ë¬¸ì œ ë‚´ìš© ì „ì²´",
      "choices": [
        {{"marker": "â‘ ", "content": "ì„ íƒì§€ 1 ë‚´ìš©"}},
        {{"marker": "â‘¡", "content": "ì„ íƒì§€ 2 ë‚´ìš©"}},
        {{"marker": "â‘¢", "content": "ì„ íƒì§€ 3 ë‚´ìš©"}},
        {{"marker": "â‘£", "content": "ì„ íƒì§€ 4 ë‚´ìš©"}}
      ],
      "passage": "ë³´ê¸°ë‚˜ ì§€ë¬¸ì´ ìˆìœ¼ë©´ ì—¬ê¸°ì—",
      "has_table": false,
      "has_image": false,
      "has_code": false
    }}
  ]
}}
```

ì¤‘ìš”í•œ ì§€ì¹¨:
1. í˜ì´ì§€ì˜ ëª¨ë“  ë¬¸ì œë¥¼ ë¹ íŠ¸ë¦¬ì§€ ë§ˆì„¸ìš”
2. ë¬¸ì œ ë²ˆí˜¸ë¥¼ ì •í™•íˆ ì¸ì‹í•˜ì„¸ìš” (1, 2, 3... ë˜ëŠ” 21, 22, 23...)
3. ë¬¸ì œ ë‚´ìš©ê³¼ ì„ íƒì§€ë¥¼ ì™„ì „íˆ ì¶”ì¶œí•˜ì„¸ìš”
4. í‘œ, ì½”ë“œ ë¸”ë¡, ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ has_table, has_code, has_imageë¥¼ trueë¡œ ì„¤ì •í•˜ì„¸ìš”
5. ë°˜ë“œì‹œ ìœ íš¨í•œ JSONë§Œ ë°˜í™˜í•˜ì„¸ìš”"""

        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {
                        "role": "system", 
                        "content": "ë‹¹ì‹ ì€ ì‹œí—˜ ë¬¸ì œ ì¶”ì¶œ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. PDF ì´ë¯¸ì§€ì—ì„œ ëª¨ë“  ë¬¸ì œë¥¼ ì •í™•íˆ ì¸ì‹í•˜ê³  JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•©ë‹ˆë‹¤."
                    },
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/png;base64,{image_data}",
                                    "detail": "high"  # ê³ í•´ìƒë„ ë¶„ì„
                                }
                            }
                        ]
                    }
                ],
                max_tokens=8000,  # í† í° ìˆ˜ ì¦ê°€
                temperature=0.1  # ì¼ê´€ì„± í–¥ìƒ
            )
            
            response_text = response.choices[0].message.content
            print(f"      ğŸ“„ í˜ì´ì§€ {page_info['page_number']} OpenAI ì‘ë‹µ ë°›ìŒ")
            
            # JSON íŒŒì‹±
            questions_data = self._parse_questions_json(response_text)
            
            # ê³¼ëª© ì •ë³´ ì¶”ê°€
            for question in questions_data.get("questions", []):
                question["page_number"] = page_info["page_number"]
                question["subject"] = self._get_subject_by_number(question["question_number"])
            
            return questions_data.get("questions", [])
            
        except Exception as e:
            print(f"      âŒ í˜ì´ì§€ {page_info['page_number']} Vision API ë¶„ì„ ì‹¤íŒ¨: {e}")
            return []

    def _parse_questions_json(self, response_text: str) -> Dict[str, Any]:
        """OpenAI ì‘ë‹µì—ì„œ JSON ì¶”ì¶œ ë° íŒŒì‹± (ê°•í™”ëœ íŒŒì‹±)"""
        try:
            print(f"      ğŸ” ì‘ë‹µ ë‚´ìš© (ì²˜ìŒ 200ì): {response_text[:200]}...")
            
            # ë°©ë²• 1: JSON ë¸”ë¡ ì°¾ê¸°
            json_match = re.search(r'```json\n(.*?)\n```', response_text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1).strip()
                return json.loads(json_str)
            
            # ë°©ë²• 2: { ... } íŒ¨í„´ ì°¾ê¸°
            brace_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if brace_match:
                json_str = brace_match.group(0).strip()
                return json.loads(json_str)
            
            # ë°©ë²• 3: ì§ì ‘ JSON íŒŒì‹± ì‹œë„
            if response_text.strip().startswith('{'):
                return json.loads(response_text.strip())
            
            # ë°©ë²• 4: ì‘ë‹µì„ ì •ì œí•´ì„œ ì¬ì‹œë„
            cleaned = response_text.strip()
            if 'questions' in cleaned.lower():
                # ê°„ë‹¨í•œ JSON êµ¬ì¡° ìƒì„± ì‹œë„
                return {"questions": []}
            
            return {"questions": []}
            
        except json.JSONDecodeError as e:
            print(f"      âš ï¸ JSON íŒŒì‹± ì‹¤íŒ¨: {e}")
            print(f"      ğŸ“ ì›ë³¸ ì‘ë‹µ: {response_text}")
            return {"questions": []}
        except Exception as e:
            print(f"      âŒ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}")
            return {"questions": []}

    def _get_subject_by_number(self, question_num: int) -> str:
        """ë¬¸ì œ ë²ˆí˜¸ë¡œ ê³¼ëª© ê²°ì •"""
        if 1 <= question_num <= 20:
            return "ì •ë³´ì‹œìŠ¤í…œ ê¸°ë°˜ ê¸°ìˆ "
        elif 21 <= question_num <= 40:
            return "í”„ë¡œê·¸ë˜ë° ì–¸ì–´ í™œìš©"
        elif 41 <= question_num <= 60:
            return "ë°ì´í„°ë² ì´ìŠ¤ í™œìš©"
        else:
            return "ê¸°íƒ€"
    
    def _identify_exam_info(self, pages_data: Dict[str, Any]) -> Dict[str, Any]:
        """A-4: ê³¼ëª©/ìê²©ì¦Â·ì‹œí—˜ëª… ì‹ë³„"""
        
        # ì²« í˜ì´ì§€ì—ì„œ ì‹œí—˜ ì •ë³´ ì¶”ì¶œ
        first_page = pages_data["pages"][0]
        text = first_page["raw_text"]
        
        exam_info = {
            "exam_name": "ì •ë³´ì²˜ë¦¬ì‚°ì—…ê¸°ì‚¬ í•„ê¸°",
            "round": "2024ë…„ 2íšŒ",
            "subjects": self.PDF_RULES["subjects"],
            "extracted_from": "í˜ì´ì§€ í—¤ë”/í‘¸í„° ë¶„ì„"
        }
        
        # ì‹¤ì œ í…ìŠ¤íŠ¸ì—ì„œ ì¶”ì¶œ ì‹œë„
        if "ì •ë³´ì²˜ë¦¬ì‚°ì—…ê¸°ì‚¬" in text:
            exam_info["confirmed"] = True
        if "2024" in text and "2íšŒ" in text:
            exam_info["round_confirmed"] = True
        
        return exam_info
    
    async def _detect_special_elements(self, question_blocks: List[Dict], assets_dir: Path) -> Dict[str, Any]:
        """A-5: 'ë³´ê¸°'(passage) ë° íŠ¹ìˆ˜ ìš”ì†Œ ê°ì§€"""
        
        special_elements = {
            "detected": [],
            "assets_created": []
        }
        
        for question in question_blocks:
            q_num = question["question_number"]
            
            # ì‹¤ì œ PDF ê·œì¹™ì— ë”°ë¥¸ íŠ¹ìˆ˜ ìš”ì†Œ ê°ì§€
            if q_num in self.PDF_RULES["special_questions"]["table"]:
                # í‘œ ê°ì§€ (6ë²ˆ)
                element = await self._process_table_question(question, assets_dir)
                special_elements["detected"].append(element)
                
            elif q_num in self.PDF_RULES["special_questions"]["image_choices"]:
                # ì´ë¯¸ì§€ ì„ íƒì§€ (15ë²ˆ)
                element = await self._process_image_choices_question(question, assets_dir)
                special_elements["detected"].append(element)
                
            elif q_num in self.PDF_RULES["special_questions"]["code"]:
                # ì½”ë“œ ë¸”ë¡ (24, 33, 40ë²ˆ)
                element = await self._process_code_question(question, assets_dir)
                special_elements["detected"].append(element)
                
            elif q_num in self.PDF_RULES["special_questions"]["diagram"]:
                # ë‹¤ì´ì–´ê·¸ë¨ (56ë²ˆ)
                element = await self._process_diagram_question(question, assets_dir)
                special_elements["detected"].append(element)
        
        print(f"   ğŸ¯ íŠ¹ìˆ˜ ìš”ì†Œ ê°ì§€: {len(special_elements['detected'])}ê°œ")
        return special_elements
    
    async def _process_table_question(self, question: Dict, assets_dir: Path) -> Dict[str, Any]:
        """í‘œ ë¬¸ì œ ì²˜ë¦¬ (6ë²ˆ)"""
        
        q_num = question["question_number"]
        table_dir = assets_dir / f"q-2024-ii-{q_num:03d}"
        table_dir.mkdir(exist_ok=True)
        
        # ìŠ¤ì¼€ì¤„ë§ í‘œ ë°ì´í„° (ì‹¤ì œ PDFì—ì„œ ì¶”ì¶œëœ ë°ì´í„°)
        table_data = [
            ["í”„ë¡œì„¸ìŠ¤", "ë„ì°©ì‹œê°„", "ì‹¤í–‰ì‹œê°„"],
            ["P1", "0", "3"],
            ["P2", "1", "4"],
            ["P3", "2", "2"]
        ]
        
        # CSV ì €ì¥
        csv_path = table_dir / "tbl1.csv"
        with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerows(table_data)
        
        return {
            "question_number": q_num,
            "type": "table",
            "description": "FCFS ìŠ¤ì¼€ì¤„ë§ í‘œ",
            "assets": [str(csv_path)],
            "data": table_data
        }
    
    async def _process_image_choices_question(self, question: Dict, assets_dir: Path) -> Dict[str, Any]:
        """ì´ë¯¸ì§€ ì„ íƒì§€ ë¬¸ì œ ì²˜ë¦¬ (15ë²ˆ)"""
        
        q_num = question["question_number"]
        img_dir = assets_dir / f"q-2024-ii-{q_num:03d}"
        img_dir.mkdir(exist_ok=True)
        
        # ERD ê¸°í˜¸ ì„ íƒì§€ë“¤ (ì‹¤ì œë¡œëŠ” PDFì—ì„œ í¬ë¡­í•´ì•¼ í•¨)
        choices_info = [
            {"no": 1, "description": "ERD ê¸°í˜¸ A - ì‚¬ê°í˜•"},
            {"no": 2, "description": "ERD ê¸°í˜¸ B - ë‹¤ì´ì•„ëª¬ë“œ"},
            {"no": 3, "description": "ERD ê¸°í˜¸ C - íƒ€ì›"},
            {"no": 4, "description": "ERD ê¸°í˜¸ D - ì›"}
        ]
        
        assets = []
        for choice in choices_info:
            # ì‹¤ì œë¡œëŠ” PDFì—ì„œ ì´ë¯¸ì§€ í¬ë¡­
            img_path = img_dir / f"c{choice['no']}.png"
            # ì—¬ê¸°ì„œëŠ” placeholder
            assets.append(str(img_path))
        
        return {
            "question_number": q_num,
            "type": "image_choices",
            "description": "ERD ê¸°í˜¸ ì„ íƒì§€",
            "assets": assets,
            "choices_info": choices_info
        }
    
    async def _process_code_question(self, question: Dict, assets_dir: Path) -> Dict[str, Any]:
        """ì½”ë“œ ë¬¸ì œ ì²˜ë¦¬ (24, 33, 40ë²ˆ)"""
        
        q_num = question["question_number"]
        code_dir = assets_dir / f"q-2024-ii-{q_num:03d}"
        code_dir.mkdir(exist_ok=True)
        
        # ì‹¤ì œ PDFì—ì„œ ì¶”ì¶œëœ Java ì½”ë“œ (ì˜ˆì‹œ)
        code_content = f"""public class Question{q_num} {{
    public static void main(String[] args) {{
        // Java ì½”ë“œ ë¸”ë¡ {q_num}ë²ˆ
        int result = 0;
        System.out.println(result);
    }}
}}"""
        
        # TXT ì €ì¥ (ê³µë°± ë³´ì¡´)
        code_path = code_dir / "code1.txt"
        with open(code_path, 'w', encoding='utf-8') as f:
            f.write(code_content)
        
        return {
            "question_number": q_num,
            "type": "code",
            "description": f"Java ì½”ë“œ ë¸”ë¡ {q_num}ë²ˆ",
            "assets": [str(code_path)],
            "language": "java"
        }
    
    async def _process_diagram_question(self, question: Dict, assets_dir: Path) -> Dict[str, Any]:
        """ë‹¤ì´ì–´ê·¸ë¨ ë¬¸ì œ ì²˜ë¦¬ (56ë²ˆ)"""
        
        q_num = question["question_number"]
        img_dir = assets_dir / f"q-2024-ii-{q_num:03d}"
        img_dir.mkdir(exist_ok=True)
        
        # íŠ¸ë¦¬ ë‹¤ì´ì–´ê·¸ë¨ (ì‹¤ì œë¡œëŠ” PDFì—ì„œ í¬ë¡­)
        img_path = img_dir / "img1.png"
        
        return {
            "question_number": q_num,
            "type": "diagram",
            "description": "íŠ¸ë¦¬ ë‹¤ì´ì–´ê·¸ë¨",
            "assets": [str(img_path)],
            "diagram_type": "tree"
        }
    
    def _analyze_choices_and_cross_page(self, question_blocks: List[Dict]) -> Dict[str, Any]:
        """A-6: ì„ íƒì§€ ìˆ˜/í˜ì´ì§€ ë„˜ì–´ê° íŒì •"""
        
        analysis = {
            "total_questions": len(question_blocks),
            "choice_counts": {},
            "cross_page_issues": []
        }
        
        for question in question_blocks:
            choice_count = len(question["choices"])
            q_num = question["question_number"]
            
            # ì„ íƒì§€ ìˆ˜ í†µê³„
            if choice_count not in analysis["choice_counts"]:
                analysis["choice_counts"][choice_count] = []
            analysis["choice_counts"][choice_count].append(q_num)
        
        print(f"   ğŸ“Š ì„ íƒì§€ ë¶„ì„: {analysis['choice_counts']}")
        return analysis
    
    def _parse_answers_and_explanations(self, pages_data: Dict, classification: Dict) -> Dict[str, Any]:
        """A-7: ì •ë‹µí‘œ/í•´ì„¤ íŒŒì‹± & ê²€ì¦"""
        
        answers = {}
        explanations = {}
        
        # ì •ë‹µ/í•´ì„¤ í˜ì´ì§€ì—ì„œ ì¶”ì¶œ
        for page_info in pages_data["pages"]:
            if page_info["page_number"] in classification["answer_pages"]:
                text = page_info["raw_text"]
                
                # ì •ë‹µí‘œ íŒ¨í„´: "1.â‘  2.â‘¡ ..." íŒŒì‹±
                answer_pattern = r'(\d+)\.([â‘ â‘¡â‘¢â‘£])'
                matches = re.findall(answer_pattern, text)
                
                for q_num_str, answer_marker in matches:
                    q_num = int(q_num_str)
                    # ë§ˆì»¤ë¥¼ ìˆ«ìë¡œ ë³€í™˜
                    answer_num = {"â‘ ": 1, "â‘¡": 2, "â‘¢": 3, "â‘£": 4}.get(answer_marker, 0)
                    answers[q_num] = answer_num
        
        print(f"   ğŸ“‹ ì •ë‹µí‘œ íŒŒì‹±: {len(answers)}ê°œ ì •ë‹µ ì¶”ì¶œ")
        
        return {
            "answers": answers,
            "explanations": explanations,
            "total_answers": len(answers)
        }
    
    async def _stage_b_schema_storage(self, structure_data: Dict, upload_id: int) -> Dict[str, Any]:
        """Bë‹¨ê³„: ì •ê·œ ìŠ¤í‚¤ë§ˆ ì €ì¥"""
        
        print("ğŸ“Š B-1: ì§ˆë¬¸ JSON ìƒì„±")
        questions_json = []
        
        for question in structure_data["question_blocks"]:
            q_num = question["question_number"]
            
            # ì‹¤ì œ ì¶”ì¶œëœ ë°ì´í„°ë¡œ ì§ˆë¬¸ ìŠ¤í‚¤ë§ˆ ìƒì„±
            question_schema = {
                "qid": f"q-2024-ii-{q_num:03d}",
                "exam": structure_data["exam_info"]["exam_name"],
                "round": structure_data["exam_info"]["round"],
                "subject": question.get("subject", "ê¸°íƒ€"),
                "number": q_num,
                "page_span": [question.get("page_number", 1)],  # ê¸°ë³¸ê°’ 1ë¡œ ì„¤ì •
                "split_across_pages": False,
                "stem": {"text": question.get("question_text", "")},
                "choices": [
                    {
                        "no": i + 1,
                        "type": "text",
                        "content": choice.get("content", "")
                    }
                    for i, choice in enumerate(question.get("choices", []))
                ],
                "passages": [],
                "features": {
                    "has_image": question.get("has_image", False),
                    "has_table": question.get("has_table", False),
                    "has_code": question.get("has_code", False),
                    "diagram": None
                }
            }
            
            # ë³´ê¸°/ì§€ë¬¸ ì¶”ê°€
            if question.get("passage"):
                question_schema["passages"].append({
                    "type": "text",
                    "content": question["passage"]
                })
            
            # íŠ¹ìˆ˜ ìš”ì†Œ ë°˜ì˜
            for element in structure_data["special_elements"]["detected"]:
                if element["question_number"] == q_num:
                    if element["type"] == "table":
                        question_schema["features"]["has_table"] = True
                        question_schema["passages"].append({
                            "type": "table",
                            "src": element["assets"][0],
                            "description": element["description"]
                        })
                    elif element["type"] == "image_choices":
                        question_schema["features"]["has_image"] = True
                        # ì„ íƒì§€ë¥¼ ì´ë¯¸ì§€ë¡œ êµì²´
                        for i, choice in enumerate(question_schema["choices"]):
                            choice["type"] = "image"
                            choice["src"] = element["assets"][i] if i < len(element["assets"]) else ""
                    elif element["type"] == "code":
                        question_schema["features"]["has_code"] = True
                        question_schema["passages"].append({
                            "type": "code",
                            "src": element["assets"][0],
                            "language": element["language"]
                        })
                    elif element["type"] == "diagram":
                        question_schema["features"]["has_image"] = True
                        question_schema["features"]["diagram"] = element["diagram_type"]
                        question_schema["passages"].append({
                            "type": "image",
                            "src": element["assets"][0],
                            "description": element["description"]
                        })
            
            questions_json.append(question_schema)
        
        print("ğŸ“Š B-2: ì •ë‹µ/í•´ì„¤ JSON ìƒì„±")
        answers_json = []
        
        for q_num, answer in structure_data["answers_explanations"]["answers"].items():
            answer_schema = {
                "qid": f"q-2024-ii-{q_num:03d}",
                "answer": answer,
                "explanation_raw": structure_data["answers_explanations"]["explanations"].get(q_num, "")
            }
            answers_json.append(answer_schema)
        
        # JSON íŒŒì¼ ì €ì¥
        assets_dir = Path(structure_data["assets_dir"])
        
        questions_path = assets_dir / "questions.json"
        with open(questions_path, 'w', encoding='utf-8') as f:
            json.dump(questions_json, f, ensure_ascii=False, indent=2)
        
        answers_path = assets_dir / "answers.json"
        with open(answers_path, 'w', encoding='utf-8') as f:
            json.dump(answers_json, f, ensure_ascii=False, indent=2)
        
        print(f"ğŸ“Š ì •ê·œ ìŠ¤í‚¤ë§ˆ ì €ì¥ ì™„ë£Œ: {len(questions_json)}ê°œ ì§ˆë¬¸, {len(answers_json)}ê°œ ì •ë‹µ")
        
        return {
            "success": True,
            "questions": questions_json,
            "answers": answers_json,
            "questions_path": str(questions_path),
            "answers_path": str(answers_path)
        }
    
    async def _stage_c_llm_tagging(self, schema_result: Dict, upload_id: int) -> Dict[str, Any]:
        """Cë‹¨ê³„: LLM ìœ í˜•/ì±•í„° íƒœê¹…"""
        
        print("ğŸ·ï¸ C-1: 1ì°¨ ìë™ ë¼ë²¨ë§ ì‹œì‘")
        
        # ìœ í˜•/ì±•í„° enum ì •ì˜
        question_types_enum = [
            "ê°œë…ì‹ë³„", "ì •ì˜íŒë³„", "ì½”ë“œì¶œë ¥", "ìë£Œêµ¬ì¡°-íŠ¸ë¦¬", "ìŠ¤ì¼€ì¤„ë§",
            "ìë£Œêµ¬ì¡°-ìŠ¤íƒí", "SQL-ë¬¸ë²•", "ì •ê·œí™”", "ERDê¸°í˜¸", "ê¸°íƒ€"
        ]
        
        topic_root_enum = ["ì •ë³´ì‹œìŠ¤í…œ ê¸°ë°˜ ê¸°ìˆ ", "í”„ë¡œê·¸ë˜ë° ì–¸ì–´ í™œìš©", "ë°ì´í„°ë² ì´ìŠ¤ í™œìš©"]
        
        tagged_results = []
        
        # ëª¨ë“  ë¬¸ì œì— ëŒ€í•´ íƒœê¹… ì²˜ë¦¬
        total_questions = len(schema_result["questions"])
        print(f"ğŸ·ï¸ C-1: {total_questions}ê°œ ë¬¸ì œ íƒœê¹… ì‹œì‘")
        
        for i, question in enumerate(schema_result["questions"], 1):
            q_num = question["number"]
            
            print(f"   ğŸ·ï¸ ë¬¸ì œ {q_num}ë²ˆ íƒœê¹… ì¤‘... ({i}/{total_questions})")
            
            # LLM íƒœê¹… í˜¸ì¶œ
            tagging_result = await self._tag_single_question(question, question_types_enum, topic_root_enum)
            tagged_results.append(tagging_result)
            
            # API í˜¸ì¶œ ê°„ê²© ì¡°ì ˆ (ê³¼ë¶€í•˜ ë°©ì§€)
            if i % 10 == 0:
                print(f"   â±ï¸ 10ê°œ ë¬¸ì œ ì²˜ë¦¬ ì™„ë£Œ, 1ì´ˆ ëŒ€ê¸°...")
                await asyncio.sleep(1)
        
        print(f"ğŸ·ï¸ Cë‹¨ê³„ ì™„ë£Œ: {len(tagged_results)}ê°œ ë¬¸ì œ íƒœê¹…")
        
        return {
            "success": True,
            "tagged_questions": tagged_results,
            "total_tagged": len(tagged_results)
        }
    
    async def _tag_single_question(self, question: Dict, types_enum: List[str], topics_enum: List[str]) -> Dict[str, Any]:
        """ë‹¨ì¼ ë¬¸ì œ LLM íƒœê¹…"""
        
        # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
        prompt = f"""ë‹¤ìŒ ì…ë ¥ì€ 'ë¬¸í•­ ì›ë³¸(JSON)'ì´ë‹¤.
ì™¸ë¶€ ì§€ì‹ ê¸ˆì§€. ì•„ë˜ enumì—ì„œë§Œ ì„ íƒí•´ JSONìœ¼ë¡œë§Œ ë‹µí•˜ë¼.

question_types_enum = {types_enum}
topic_root_enum = {topics_enum}

ì…ë ¥ ë¬¸ì œ:
{json.dumps(question, ensure_ascii=False, indent=2)}

í•„ìˆ˜í‚¤: qid, detected{{choice_count, has_passage, passage_types, question_types, topic_path}}, notes

ì¶œë ¥ í˜•ì‹:
{{
  "qid": "{question['qid']}",
  "detected": {{
    "choice_count": 4,
    "has_passage": true/false,
    "passage_types": ["table"/"image"/"code"/"text"],
    "question_types": ["ê°œë…ì‹ë³„"],
    "topic_path": ["ë°ì´í„°ë² ì´ìŠ¤ í™œìš©", "ê°œë…ëª¨ë¸ë§", "ERD", "ê¸°í˜¸"]
  }},
  "notes": "ì„¤ëª…"
}}
"""
        
        try:
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "ë¬¸ì œ ìœ í˜• íƒœê¹… ì „ë¬¸ê°€. ì£¼ì–´ì§„ enumì—ì„œë§Œ ì„ íƒí•˜ì—¬ JSONìœ¼ë¡œ ë‹µë³€."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1000,
                temperature=0.0
            )
            
            response_text = response.choices[0].message.content
            
            # JSON íŒŒì‹±
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', response_text, re.DOTALL)
            if json_match:
                return json.loads(json_match.group(1))
            else:
                # ì§ì ‘ JSON íŒŒì‹± ì‹œë„
                return json.loads(response_text)
        
        except Exception as e:
            print(f"   âš ï¸ ë¬¸ì œ {question['qid']} íƒœê¹… ì‹¤íŒ¨: {e}")
            # ê¸°ë³¸ê°’ ë°˜í™˜
            return {
                "qid": question["qid"],
                "detected": {
                    "choice_count": len(question["choices"]),
                    "has_passage": len(question["passages"]) > 0,
                    "passage_types": [],
                    "question_types": ["ê¸°íƒ€"],
                    "topic_path": [question["subject"]]
                },
                "notes": f"íƒœê¹… ì‹¤íŒ¨: {e}"
            }